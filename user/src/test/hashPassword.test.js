const bcrypt = require('bcrypt');
const {comparePassword} = require('../utils/hashPassword')
describe('comparePassword', () => {
    // Returns true if the password matches the hash
    it('should return true when password matches hash', async () => {
      const password = 'password123';
      const salt = await bcrypt.genSalt(10);
      const hash = await bcrypt.hash(password, salt);

      const result = await comparePassword(password, hash);

      expect(result).toBe(true);
    });
    // Returns false if password or hash is empty string
    it('should return false when password is empty string', async () => {
      const password = '';
      const hash = await bcrypt.hash('password123', 10);

      const result = await comparePassword(password, hash);

      expect(result).toBe(false);
    });

    // Returns false if the password does not match the hash
    it('should return false when password does not match hash', async () => {
      const password = 'password123';
      const incorrectPassword = 'incorrectPassword';
      const salt = await bcrypt.genSalt(10);
      const hash = await bcrypt.hash(password, salt);

      const result = await comparePassword(incorrectPassword, hash);

      expect(result).toBe(false);
    });

    // Works with passwords and hashes generated by hashPassword function
    it('should return true when password matches hash', async () => {
      const password = 'password123';
      const salt = await bcrypt.genSalt(10);
      const hash = await bcrypt.hash(password, salt);

      const result = await comparePassword(password, hash);

      expect(result).toBe(true);
    });

    // Works with passwords and hashes generated by external bcrypt library
    it('should return true when password matches hash', async () => {
      const password = 'password123';
      const salt = await bcrypt.genSalt(10);
      const hash = await bcrypt.hash(password, salt);

      const result = await comparePassword(password, hash);

      expect(result).toBe(true);
    });

    // Handles passwords and hashes of different lengths
    it('should return false when password and hash have different lengths', async () => {
      const password = 'password123';
      const hash = 'hashedPassword';

      const result = await comparePassword(password, hash);

      expect(result).toBe(false);
    });

    // Handles passwords and hashes with special characters
    it('should return true when password matches hash with special characters', async () => {
      const password = 'password!@#$%^&*()';
      const salt = await bcrypt.genSalt(10);
      const hash = await bcrypt.hash(password, salt);

      const result = await comparePassword(password, hash);
      expect(result).toBe(true);
    });

    // Handles passwords and hashes with non-ASCII characters
    it('should return true when password with non-ASCII characters matches hash with non-ASCII characters', async () => {
      const password = 'パスワード123';
      const salt = await bcrypt.genSalt(10);
      const hash = await bcrypt.hash(password, salt);

      const result = await comparePassword(password, hash);
      expect(result).toBe(true);
    });

    // Throws error if password or hash is not a string
    it('should not throw an error when both password and hash are strings', async () => {
      const password = 'password';
      const hash = 'hashedPassword';

      await expect(comparePassword(password, hash)).resolves.not.toThrowError();
    });

    // Handles edge cases for maximum bcrypt salt rounds
    it('should return true when password matches hash', async () => {
      const password = 'password123';
      const salt = await bcrypt.genSalt(10);
      const hash = await bcrypt.hash(password, salt);

      const result = await comparePassword(password, hash);
      expect(result).toBe(true);
    });

    // Works with different bcrypt salt rounds
    it('should return true when password matches hash', async () => {
      const password = 'password123';
      const salt = await bcrypt.genSalt(10);
      const hash = await bcrypt.hash(password, salt);

      const result = await comparePassword(password, hash);
      expect(result).toBe(true);
    });

    // Handles edge cases for minimum bcrypt salt rounds
    it('should return true when password matches hash', async () => {
      const password = 'password123';
      const salt = await bcrypt.genSalt(10);
      const hash = await bcrypt.hash(password, salt);

      const result = await comparePassword(password, hash);
      expect(result).toBe(true);
    });

    // Handles edge cases for invalid bcrypt salt rounds
    it('should return false when password does not match hash', async () => {
      const password = 'password123';
      const salt = await bcrypt.genSalt(10);
      const hash = await bcrypt.hash(password, salt);

      const result = await comparePassword('wrongpassword', hash);
      expect(result).toBe(false);
    });
});
